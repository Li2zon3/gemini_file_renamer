#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Build script for Gemini File Renamer
打包脚本 - 用于创建 macOS DMG 和 Windows EXE

Usage / 使用方法:
    python build_app.py          # Build for current platform / 为当前平台打包
    python build_app.py --all    # Show instructions for all platforms / 显示所有平台说明
"""

import os
import sys
import subprocess
import shutil
from pathlib import Path

# App metadata / 应用元数据
APP_NAME = "Gemini File Renamer"
APP_NAME_SHORT = "GeminiRenamer"
VERSION = "1.0.0"
AUTHOR = "Your Name"
DESCRIPTION = "AI-powered file renaming tool using Google Gemini"
ICON_NAME = "icon"  # Without extension

# Main script / 主脚本
MAIN_SCRIPT = "gemini_file_renamer_gui.py"

# Hidden imports that PyInstaller might miss / PyInstaller 可能遗漏的隐藏导入
HIDDEN_IMPORTS = [
    "google.generativeai",
    "google.ai.generativelanguage",
    "google.api_core",
    "google.auth",
    "pymupdf",
    "fitz",
    "docx",
    "ebooklib",
    "bs4",
    "pathvalidate",
    "PIL",
    "PIL._tkinter_finder",
]

# Data files to include / 需要包含的数据文件
DATAS = []

# Packages to collect / 需要收集的包
COLLECT_SUBMODULES = [
    "google.generativeai",
    "google.ai",
    "google.api_core",
    "ebooklib",
]


def check_dependencies():
    """Check if required tools are installed / 检查必要工具是否已安装"""
    print("Checking dependencies / 检查依赖...")
    
    try:
        import PyInstaller
        print(f"  ✓ PyInstaller {PyInstaller.__version__}")
    except ImportError:
        print("  ✗ PyInstaller not found. Installing... / PyInstaller 未找到，正在安装...")
        subprocess.run([sys.executable, "-m", "pip", "install", "pyinstaller"], check=True)
    
    # Check for main script
    if not Path(MAIN_SCRIPT).exists():
        print(f"  ✗ Main script '{MAIN_SCRIPT}' not found!")
        print(f"    Please place the script in the current directory.")
        return False
    
    print(f"  ✓ Main script found: {MAIN_SCRIPT}")
    return True


def create_spec_file():
    """Create PyInstaller spec file / 创建 PyInstaller spec 文件"""
    
    hidden_imports_str = ",\n        ".join(f"'{imp}'" for imp in HIDDEN_IMPORTS)
    collect_str = ",\n        ".join(f"'{pkg}'" for pkg in COLLECT_SUBMODULES)
    
    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
# PyInstaller spec file for {APP_NAME}
# Auto-generated by build_app.py

import sys
from PyInstaller.utils.hooks import collect_submodules, collect_data_files

block_cipher = None

# Collect all submodules
hiddenimports = [
        {hidden_imports_str}
]

# Add submodules from packages
for pkg in [{collect_str}]:
    hiddenimports.extend(collect_submodules(pkg))

# Collect data files
datas = []
for pkg in ['ebooklib']:
    datas.extend(collect_data_files(pkg))

a = Analysis(
    ['{MAIN_SCRIPT}'],
    pathex=[],
    binaries=[],
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=['matplotlib', 'numpy', 'pandas', 'scipy', 'IPython', 'jupyter'],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='{APP_NAME_SHORT}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,  # Set to True for debugging / 调试时设为 True
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='icon.ico' if sys.platform == 'win32' else 'icon.icns',
)

# macOS App Bundle
if sys.platform == 'darwin':
    app = BUNDLE(
        exe,
        name='{APP_NAME_SHORT}.app',
        icon='icon.icns',
        bundle_identifier='com.yourname.geminirename',
        info_plist={{
            'CFBundleName': '{APP_NAME}',
            'CFBundleDisplayName': '{APP_NAME}',
            'CFBundleVersion': '{VERSION}',
            'CFBundleShortVersionString': '{VERSION}',
            'NSHighResolutionCapable': True,
            'NSRequiresAquaSystemAppearance': False,
        }},
    )
'''
    
    spec_path = Path(f"{APP_NAME_SHORT}.spec")
    spec_path.write_text(spec_content, encoding='utf-8')
    print(f"Created spec file: {spec_path}")
    return spec_path


def build_windows():
    """Build Windows EXE / 构建 Windows EXE"""
    print("\n" + "="*60)
    print("Building Windows EXE / 构建 Windows EXE")
    print("="*60)
    
    spec_file = create_spec_file()
    
    # Run PyInstaller
    cmd = [
        sys.executable, "-m", "PyInstaller",
        "--clean",
        "--noconfirm",
        str(spec_file)
    ]
    
    print(f"\nRunning: {' '.join(cmd)}")
    result = subprocess.run(cmd)
    
    if result.returncode == 0:
        exe_path = Path("dist") / f"{APP_NAME_SHORT}.exe"
        print(f"\n✓ Build successful! / 构建成功!")
        print(f"  EXE location: {exe_path.absolute()}")
        return True
    else:
        print("\n✗ Build failed! / 构建失败!")
        return False


def build_macos():
    """Build macOS App / 构建 macOS App"""
    print("\n" + "="*60)
    print("Building macOS App / 构建 macOS App")
    print("="*60)
    
    spec_file = create_spec_file()
    
    # Run PyInstaller
    cmd = [
        sys.executable, "-m", "PyInstaller",
        "--clean",
        "--noconfirm",
        str(spec_file)
    ]
    
    print(f"\nRunning: {' '.join(cmd)}")
    result = subprocess.run(cmd)
    
    if result.returncode == 0:
        app_path = Path("dist") / f"{APP_NAME_SHORT}.app"
        print(f"\n✓ Build successful! / 构建成功!")
        print(f"  App location: {app_path.absolute()}")
        return True
    else:
        print("\n✗ Build failed! / 构建失败!")
        return False


def create_dmg():
    """Create macOS DMG / 创建 macOS DMG"""
    print("\n" + "="*60)
    print("Creating DMG / 创建 DMG")
    print("="*60)
    
    app_path = Path("dist") / f"{APP_NAME_SHORT}.app"
    dmg_path = Path("dist") / f"{APP_NAME_SHORT}-{VERSION}.dmg"
    
    if not app_path.exists():
        print(f"✗ App not found: {app_path}")
        print("  Please run build first.")
        return False
    
    # Remove old DMG if exists
    if dmg_path.exists():
        dmg_path.unlink()
    
    # Create DMG using hdiutil
    cmd = [
        "hdiutil", "create",
        "-volname", APP_NAME,
        "-srcfolder", str(app_path),
        "-ov",
        "-format", "UDZO",
        str(dmg_path)
    ]
    
    print(f"\nRunning: {' '.join(cmd)}")
    result = subprocess.run(cmd)
    
    if result.returncode == 0:
        print(f"\n✓ DMG created! / DMG 创建成功!")
        print(f"  DMG location: {dmg_path.absolute()}")
        return True
    else:
        print("\n✗ DMG creation failed! / DMG 创建失败!")
        return False


def create_windows_installer_script():
    """Create Inno Setup script for Windows installer / 创建 Windows 安装程序脚本"""
    
    iss_content = f'''; Inno Setup Script for {APP_NAME}
; 使用 Inno Setup 创建 Windows 安装程序

[Setup]
AppName={APP_NAME}
AppVersion={VERSION}
AppPublisher={AUTHOR}
DefaultDirName={{autopf}}\\{APP_NAME_SHORT}
DefaultGroupName={APP_NAME}
OutputBaseFilename={APP_NAME_SHORT}-{VERSION}-Setup
Compression=lzma2
SolidCompression=yes
WizardStyle=modern
PrivilegesRequired=lowest

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"
Name: "chinesesimplified"; MessagesFile: "compiler:Languages\\ChineseSimplified.isl"

[Tasks]
Name: "desktopicon"; Description: "Create a desktop shortcut"; GroupDescription: "Additional icons:"

[Files]
Source: "dist\\{APP_NAME_SHORT}.exe"; DestDir: "{{app}}"; Flags: ignoreversion

[Icons]
Name: "{{group}}\\{APP_NAME}"; Filename: "{{app}}\\{APP_NAME_SHORT}.exe"
Name: "{{autodesktop}}\\{APP_NAME}"; Filename: "{{app}}\\{APP_NAME_SHORT}.exe"; Tasks: desktopicon

[Run]
Filename: "{{app}}\\{APP_NAME_SHORT}.exe"; Description: "Launch {APP_NAME}"; Flags: nowait postinstall skipifsilent
'''
    
    iss_path = Path(f"{APP_NAME_SHORT}.iss")
    iss_path.write_text(iss_content, encoding='utf-8')
    print(f"\nCreated Inno Setup script: {iss_path}")
    print("  Use Inno Setup Compiler to create the installer.")
    return iss_path


def print_instructions():
    """Print build instructions / 打印构建说明"""
    
    instructions = f'''
{'='*70}
Gemini File Renamer - Build Instructions / 构建说明
{'='*70}

Prerequisites / 前置要求:
  1. Python 3.8+ with all dependencies installed / Python 3.8+ 并安装所有依赖
  2. PyInstaller: pip install pyinstaller
  3. Place '{MAIN_SCRIPT}' in the current directory / 将主脚本放在当前目录

{'='*70}
WINDOWS - Creating EXE / 创建 EXE 文件
{'='*70}

Method 1: Using this script / 使用此脚本:
  python build_app.py

Method 2: Manual / 手动:
  pyinstaller --onefile --windowed --name=GeminiRenamer \\
    --hidden-import=google.generativeai \\
    --hidden-import=pymupdf \\
    --hidden-import=docx \\
    --hidden-import=ebooklib \\
    --hidden-import=bs4 \\
    gemini_file_renamer_gui.py

Output: dist/GeminiRenamer.exe

Optional - Create installer with Inno Setup:
  1. Download Inno Setup from https://jrsoftware.org/isinfo.php
  2. Run this script to generate .iss file
  3. Compile with Inno Setup

{'='*70}
macOS - Creating DMG / 创建 DMG 文件
{'='*70}

Method 1: Using this script (on macOS) / 使用此脚本（在 macOS 上）:
  python build_app.py

Method 2: Manual / 手动:
  # Step 1: Build app bundle / 构建应用包
  pyinstaller --onefile --windowed --name=GeminiRenamer \\
    --osx-bundle-identifier=com.yourname.geminirename \\
    --hidden-import=google.generativeai \\
    --hidden-import=pymupdf \\
    gemini_file_renamer_gui.py

  # Step 2: Create DMG / 创建 DMG
  hdiutil create -volname "Gemini File Renamer" \\
    -srcfolder dist/GeminiRenamer.app \\
    -ov -format UDZO \\
    dist/GeminiRenamer-{VERSION}.dmg

{'='*70}
Cross-Platform Notes / 跨平台注意事项
{'='*70}

⚠️  You must build on the target platform! / 必须在目标平台上构建！
    - Build EXE on Windows / 在 Windows 上构建 EXE
    - Build DMG on macOS / 在 macOS 上构建 DMG

For cross-platform builds, consider: / 跨平台构建可考虑：
    - GitHub Actions (see workflow file below)
    - Virtual machines
    - Cloud build services

{'='*70}
Troubleshooting / 故障排除
{'='*70}

1. "Module not found" errors / 模块未找到错误:
   - Add to --hidden-import list / 添加到 --hidden-import 列表

2. App crashes on startup / 应用启动时崩溃:
   - Build with --console flag first / 先用 --console 标志构建
   - Check console output for errors / 检查控制台输出的错误

3. Large file size / 文件过大:
   - Add more exclusions / 添加更多排除项
   - Use UPX compression / 使用 UPX 压缩

4. Code signing (macOS) / 代码签名:
   - Required for distribution / 分发时需要
   - Use: codesign --deep --force --sign "Developer ID" app.app

'''
    print(instructions)


def main():
    """Main entry point / 主入口"""
    
    if "--help" in sys.argv or "-h" in sys.argv:
        print_instructions()
        return
    
    if "--instructions" in sys.argv or "--all" in sys.argv:
        print_instructions()
        return
    
    if not check_dependencies():
        return
    
    platform = sys.platform
    
    if platform == "win32":
        success = build_windows()
        if success:
            create_windows_installer_script()
            
    elif platform == "darwin":
        success = build_macos()
        if success:
            create_dmg()
            
    else:
        print(f"Platform '{platform}' detected.")
        print("This script supports Windows and macOS directly.")
        print("For Linux, you can create an AppImage or Flatpak.")
        print("\nRun with --instructions for manual build steps.")


if __name__ == "__main__":
    main()
